# 刷题笔记
----------
## 1.数组 
## 2.字符串
## 3.链表
## 4.栈&队列
## 5.树
## 6.排序&查找
## 7.动态规划&贪心算法
### 剪绳子
> 题目：给你一个长度为$n$的绳子，把绳子剪成$m$段($m,n$都是整数，$ n>1, m >1$)，每段绳子的长度记为$k[0], k[1], ...k[m]$。请问$k[0]×k[1]×...×k[m]$的最大值是多少？

> **分析：**题目的要求是$m>1$，即最少是切两段。
> 首先定义一个$f(n)$为绳子长度为$n$时剪成若干段长度的乘积最大值。因$m>1$，当剪第一刀的时候，有$n-1$种可能。即剪出来的长度为$1, 2, 3, ..., n-1$。则$f(n)=max(f(i)×f(n-i))$。
> 如：当绳子长度为2时，只能剪成1,1，$f(2)=1×1=1$，长度为3时，也只能剪成1,2,$f(3)=1×2=2$; 绳子长度为4时，可以剪成1,3和2,2，此时$f(4)=max(1×3, 2×2)=4$。特别需要注意的地方在于：当长度$n>=4$时，我们计算的切割长度会用到长度为3,2,乃至1的绳子，如上面的$n=4$，我们切成长度为1，3和2,2，若按照我们定义的$f(n)$的计算方法，是$f(4)=max(f(3)×f(1),f(2)×f(2))$，而实际上，当绳子长度只有3时，题目又要求至少切一段，所以，$f(3)=2,而计算$f(4)$所用到的3，则是切割后的长度，此时最大长度的就是3。2和1同理。故当编写代码的时候要考虑到这个，并将$f(2),f(3)$作为特殊值来处理。


## 8.其他
### 位运算
> 请事先一个函数，输入一个整数，输出该整数二进制表示中1的个数。例如，9的二进制是1001，有两位为1.因此，如果输入是9，则函数输出是2.

> **分析：**要整数的二进制有多少个1，常规解法是将该整数与1进行与操作，然后再右移。但是这种解法没有考虑负数的情况，当输入的数是负数的时候，右移操作的时候需要在最高位补1，故导致无限循环。为了避免这种情况，不对判断的这个数据进行移位操作，改为对与之进行位操作数进行移位。
> 先将n与1进行与操作，判断最低位是否为1，接着将1左移，再与n进行与操作，判断次位是否为1，...依次循环，即可得出正确结果。但次方法的循环次数与flag的类型有关，如定义flag为unsigned int，则循环的次数为32次。
> **更高效的解法：** 将一个整数减去1，再与原来的数进行位与运算，得到的结果相当于把整数的二进制表示最右边的1变为0。如：12(1100),减去1为1011,1100 & 1011 = 1000。所以这道题就可看成：判断一个整数有多少个1，就可做几次这样的运算。
> **另外：**好多同种类型的问题，都可运算上述思想。如：判别一个整数是否是2的整数次方，即将该整数减去1再与原数进行位与操作，就把唯一的1变为0.再如：输入两个整数m和n，计算需要改变二进制的几位才能互相转换，可将这个问题看成两个操作，先将m和n进行异或操作得到不同的位数，再统计异或结果1的个数。
