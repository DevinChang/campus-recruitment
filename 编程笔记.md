# 零敲碎打的知识要点
## 取模
在数学中，取模运算的结果就是欧几里得除法的结果。
> 欧几里得除法(带余除法)。给定一个**被除数**$a$,和一个**除数**$b$,欧几里得除法给出一个**整数**$q$和一个介于一定范围的**余数**$r$，使得下式成立:$$a=bq+r$$,同样的表示为$$a \div b=q...r$$,表示为“$a除以b等于q，余r$”,且$|r|<|n|$

对于正整数的取模运算，按照欧几里得除法的性质，能简单的计算结果。如$7%3=1, 1%255=1$。另外需要了解的是，取模运算依赖于**编程语言和底层软件**。
**重点是如何对负数进行取模？**
如：(-7) % 3 = ?, 7 % (-3) = ?
计算之前，先弄清以下几个概念：

>**向上取整(Ceiling)** 
>向$+\infty$方向取最精确的整数,即取结果比实际结果稍大。如：17 /10 = **2**, 5 / 2 = **3**, -9 / 4 = **-2**

>**向下取整(Floor)** 
>向$-\infty$方向取最精确的整数,即取结果比实际结果稍小。如：17 /10 = **1**, 5 / 2 = **2**, -9 / 4 = **-3**

>**向零取整(Truncate)** 
>向$0$方向取最精确的整数,即舍去小数部分。如：17 /10 = **1**, 5 / 2 = **2**, -9 / 4 = **-2**

根据欧几里得除法公式$$a=bq+r$$,得**商**$q=\frac{a}{b}$, **余数**$r=a -( \frac{a}{b}) \cdot b$
由此可知，$r$的结果主要由$\frac{a}{b}$决定。而在计算机中，常用的除法操作有**向零取整 (truncate)**和**向下取整(floor)**

而在Cpp/Java的语言，除法的运算是truncate除法$r=a -trunc( \frac{a}{b}) \cdot b$，python等语言则是floor除法$r=a -floor( \frac{a}{b}) \cdot b$。
回归到开头的例子：
(-7) % 3 = ?, 7 % (-3) = ?
在Cpp/Java中：
(-7) % 3 = -7 - trunc(-7 / 3) * 3 = -7 - (-2) * 3 = -7 + 6 = -1,
7 % (-3) = 7 - trunc(7 / -3) * (-3) = 7 - (-2) * (-3) = 7 - 6 = 1
在python中：
(-7) % 3 = -7 - floor(-7 / 3) * 3 = -7 - (-3) * 3 = -7 + 8 = 2,
7 % (-3) = 7 - floor(7 / -3) * (-3) = 7 - (-3) * (-3) = 7 - 8 =- 2

## 类型转换
- 当赋给**无符号类型**一个**超出它范围**的值时，结果是**初始值对无符号类型表示数值总数取模后的余数**,如：
  ```cpp
  unsigned char c1 = -1	//假设char占8比特
  ```
  因为c1是无符号类型，其所表示的范围是[0, 255],因-1不在此范围内，故结果**该值**是对**区间表示数值总和**即256**取模**后的**余数**，即-1 % 256 = 255
- 当赋给**带符号类型**一个**超出范围**的值时，结果是**未定义(undefined)**的，如：
  ```cpp
  signed char c2 = 256	//假设char占8比特
  ```
  因为c2是带符号类型，其所表示的范围是[-127, 127],故256不在此范围内，其结果是未定义的，此时程序**可能继续工作，可能崩溃，也有可能产生垃圾数据**。

# 变量声明和定义
- **声明(declaration)**使得名字为程序所知，一个文件若是想使用别处定义的名字必须包含那个名字的声明。
- **定义(definition)**负责创建与名字相关的实体。
  变量可以被多次声明，但只能有一个定义。若要在不同文件中使用一个变量，则要用**extern**关键字。
  ```cpp
  extern int i; // 声明i,非定义
  int j = 1; // 定义；任何包含了显式初始化的声明即成为定义
  extern double pi = 3.14 // 定义；
  ```
# 引用和指针
- **引用(reference)**可以理解为对一个对象起了一个别名。引用必须初始化，一旦引用绑定一个对象，则其不可改变，这是引用与指针的一个区别。引用不是一个对象，故没有引用的引用。且引用只能绑定到对象上，不能与字面值或表达式结果绑定在一起。
  ```cpp
  int &val = 42; // error! 引用类型必须是一个对象。
  double dval = 3.13;
  int &rval = dval; // error! dval是double类型，rval必须初始化为一个int类型。
  ```
  引用的初始化必须是同类型的对象。如上面的例子，用double类型的初始化int型的引用则会发生错误。
- **指针(pointer)**是指向另外一种类型的复合类型。
  指针与引用相比，主要有两点不同：  

  1.指针本身也是对象，故存在指针的指针。
  2.指针无需在定义的时候赋值。
- 像&和*这种符号的多重含义。
  ```cpp
  int i = 42;
  int &r = i; // &紧随着类型名出现，因此是声明的一部分，r是一个引用
  int *p;     // *紧随着类型名出现，因此是声明的一部分，p是一个指针
  p = &i;     // &出现在表达式中，是一个取地址符
  *p = i;     // *出现在表达式中，是一个解引用符
  int &r2 = *p; // &是声明的一部分，*是一个解引用符
  ```
- 指正和引用的初始化必须是同类型的对象。如上面的例子，用double类型的初始化int型的引用则会发生错误。但有两种特殊情况：
  1.**对const的引用以及指向常量的指针指向一个非常量对象**
  ```cpp
  double dval = 3.13;
  const int &ri = dval; // 合法。是因为这样做相当于执行了 const int temp = dval; const int &ri = temp;这两步操作
  const double *cptr = &dval; // 合法；但不能通过cptr改变dval的值。
  ```
  2.**基类的指针或引用绑定到派生类对象上**
# const
- **顶层const(top-level const)**表示**指针本身**是个常量。
- **底层const(low-level const)**表示**所指的对象**是个常量。
  顶层const与底层const是取决于\*的位置，若\*在const前，则为顶层const，否则为底层const。
- 执行拷贝操作的时候，顶层const与底层const相差明显：
  拷贝操作的时候，因为拷入拷出的操作都不会改变被拷贝对象的值，故拷入拷出的对象是否为常量没有太大关系。
  而对于底层const而言，拷入拷出的对象必须具有相同的底层const资格或两个对象的数据类型可以相互转换才可拷贝赋值。
  ```cpp
  int i = 0;
  int *const p1 = &i; // top-level const
  const int ci = 42; // top-level const
  const int *p2 = &ci; // low-level const
  const int *const p3 = p2; // both
  const int &r = ci; // low-level const

  i = ci;      // 合法；
  int *p = p3; // 非法；p3包含low-level const,而p没有
  p2 = p3;     // 合法;p2与p3都包干low-level const,且top-level const没有影响
  p2 = &i;     // 合法;int*可以转换为const int *
  int &r = ci; // 非法;普通的int &不能绑定到int常量
  const int &r2 = i; //合法；const int &可以绑定到普通int上
  ```

# 类型别名
- **类型别名**是某种类型的同义词。
  ```cpp
  typedef char *pstring;     // pstring是char *的别名
  const pstring cstr = 0;    // cstr是指向char的常量指针  
  const pstring *ps;         // ps是一个指针，它的对象是指向char的常量指针
  ```
  **注意**const pstring是指向char的**常量指针**,而非**指向常量字符的指针**。
  切不可将**const pstring cstr**理解为const char *cstr,因为是按照这样展开的话，其基本数据类型就改变了。声明pstring的时候，其基本数据类型是指针，定义的cstr的数据类型也是指针，但重写后的cstr的数据类型就变成了char。

# auto与decltype
- 处理顶层const的方式不同，如果decltype使用的表达式是一个变量，则decltype返回该变量的类型(包括顶层const和引用在内)。
- auto类型说明符用编译器计算变量的初始值来推断其类型，而decltype虽然也让编译器分析表达式并得到它的类型，但是不实际计算表达式的值。
- 编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。例如， auto —般会忽略掉顶层const，而把底层const保留下来。与之相反，decltype会保留变量的顶层const。
- decltype的结果类型与表达式形式密切相关。如：变量名加上两个括号则一定表示为引用类型。则赋值会产生引用。
  ```cpp
  int a = 3, b = 4;
  decltype((a)) c = a;     // c的类型是引用，绑定到a
  decltype(a) d;           // d的类型是int
  decltype(a = b) e = b;   // e的类型是引用
  ```
